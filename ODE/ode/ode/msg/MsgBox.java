//*************************************************************************************************
package ode.msg;
//*************************************************************************************************

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;

//*************************************************************************************************
public class MsgBox {

	//=============================================================================================
	private final Map<Msg.ID, List<MsgHandler>> subscribers = new HashMap<>(); 
	//=============================================================================================
	
	//=============================================================================================
	private final Queue<Msg> cache = new LinkedList<>();
	private final Queue<Msg> queue = new LinkedList<>();
	//=============================================================================================

	//=============================================================================================
	public Builder build() {
		Msg msg = alloc();
		return new Builder(this, msg);
	}
	//=============================================================================================

	//=============================================================================================
	public void subscribe(Msg.ID id, MsgHandler handler) {
		List<MsgHandler> list = subscribers.get(id);
		if (list == null) {
			list = new ArrayList<>();
			subscribers.put(id, list);
			list.add(handler);
		} else if (!list.contains(handler)) {
			list.add(handler);
		}
	}
	//=============================================================================================

	//=============================================================================================
	public void unsubscribe(Msg.ID id, MsgHandler handler) {
		List<MsgHandler> list = subscribers.get(id);
		if (list != null) {
			list.remove(handler);
		}
	}
	//=============================================================================================

	//=============================================================================================
	void post(Msg msg) {
		synchronized (queue) {
			queue.offer(msg);
		}
	}
	//=============================================================================================
	
	//=============================================================================================
	public void update(long timeout) {
		long now = System.nanoTime();
		long mark = now + timeout;
		while (now < mark) {
			Msg msg = null;
			synchronized (queue) {
				msg = queue.poll();
			}
			if (msg != null) {
				deliver(msg);
			} else {
				break;
			}
			now = System.nanoTime();
		}
	}
	//=============================================================================================

	//=============================================================================================
	private void deliver(Msg msg) {
		List<MsgHandler> list = subscribers.get(msg.id());
		if (list != null) {
			for (MsgHandler handler : list) {
				handler.handle(msg);
			}
		}
		free(msg);
	}
	//=============================================================================================
	
	//=============================================================================================
	private Msg alloc() {
		Msg msg = null;
		synchronized (cache) {
			msg = cache.poll();
		}
		if (msg == null)
			msg = new Msg();
		return msg;
	}
	//=============================================================================================

	//=============================================================================================
	private void free(Msg msg) {
		msg.clear();
		synchronized (cache) {
			cache.offer(msg);
		}
	}
	//=============================================================================================
	
}
//*************************************************************************************************
